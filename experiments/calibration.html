<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Eye Tracking Calibration</title>

  <!-- jsPsych Core -->
  <script src="https://unpkg.com/jspsych@8.2.2"></script>
  <link rel="stylesheet" href="https://unpkg.com/jspsych@8.2.2/css/jspsych.css" />

  <!-- jsPsych Plugins -->
  <script src="https://unpkg.com/@jspsych/plugin-html-button-response@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-call-function@1.1.3"></script>

  <!-- Gaze Adapter -->
  <script src="../dist/gaze-adapter.bundle.umd.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #f0f0f0;
    }
  </style>
</head>

<body>
  <div id="jspsych-target"></div>

  <script>
    var calibration_attempts = 0;
    var final_validation_data = null;
    var adapter = new GazeAdapter();

    // Initialize jsPsych
    var jsPsych = initJsPsych({
      on_finish: function (data) {
        // Use the final_validation_data we captured
        var validation_data = final_validation_data;

        // Save model key (WebEyeTrack handles persistence internally usually, but we simulate a key)
        var model_key = 'webeyetrack_model_' + Date.now();

        // Send data to parent window
        if (window.parent !== window) {
          window.parent.postMessage({
            type: 'calibration-complete',
            average_offset: validation_data ? validation_data.rmse : null,
            recalibrated: calibration_attempts > 1,
            calibration_attempts: calibration_attempts,
            validation_data: validation_data,
            model_key: model_key
          }, '*');
          console.log('Sent calibration data to parent window');
        } else {
          // Standalone mode
          console.log('Calibration complete!');
          console.log('Validation data:', validation_data);

          var offset_text = validation_data && validation_data.rmse !== undefined
            ? validation_data.rmse.toFixed(2) + ' (RMSE)'
            : 'Not available';

          document.querySelector('#jspsych-target').innerHTML =
            '<div style="text-align: center; padding: 50px; font-family: sans-serif;">' +
            '<h2>Calibration Complete!</h2>' +
            '<p>Accuracy: ' + offset_text + '</p>' +
            '<p>Calibration attempts: ' + calibration_attempts + '</p>' +
            '<p style="color: #666; font-size: 14px;">Check console for full data</p>' +
            '</div>';
        }
      }
    });

    var timeline = [];

    // Welcome + Camera Permission Screen
    timeline.push({
      type: jsPsychHtmlButtonResponse,
      stimulus: `
        <div style="text-align: center; padding: 20px; max-width: 600px; margin: 0 auto;">
          <h2>Eye Tracking Calibration</h2>
          <p>This study requires eye tracking to verify human participation.</p>
          <p><strong>Camera Permission Required:</strong> You will be asked to allow camera access. This is necessary for eye tracking.</p>
          <p id="camera-status" style="color: #999; margin-top: 20px;">
            <em>Initializing camera...</em>
          </p>
        </div>
      `,
      choices: ['Continue'],
      on_load: async function() {
        // Disable the button initially
        const continueBtn = document.querySelector('.jspsych-btn');
        if (continueBtn) continueBtn.disabled = true;

        try {
          await adapter.init();
          document.getElementById('camera-status').innerHTML =
            '<span style="color: #2ecc71;">Camera ready</span>';
          if (continueBtn) continueBtn.disabled = false;
        } catch (e) {
          document.getElementById('camera-status').innerHTML =
            '<span style="color: #e74c3c;">Camera initialization failed: ' + e.message + '</span>';
          // Keep button disabled - user cannot proceed
        }
      }
    });

    // Calibration Sequence Function
    function create_calibration_sequence() {
      var sequence = [];

      // Instructions
      sequence.push({
        type: jsPsychHtmlButtonResponse,
        stimulus: `
          <div style="text-align: center; padding: 20px; max-width: 600px; margin: 0 auto;">
            <h3>Calibration Instructions</h3>
            <p>Green dots will appear at different positions on your screen.</p>
            <p><strong>Please:</strong></p>
            <ul style="text-align: left; margin: 20px auto; display: inline-block;">
              <li>Look directly at each dot until it disappears</li>
              <li>Use your eyes to look at the dots, not your head</li>
              <li>Stay centered and keep good lighting</li>
              <li>Sit at a comfortable distance from the screen</li>
            </ul>
            <p style="color: #666; font-size: 14px; margin-top: 20px;">
              The calibration takes about 30 seconds.
            </p>
          </div>
        `,
        choices: ['Begin Calibration']
      });

      // Run Calibration
      sequence.push({
        type: jsPsychCallFunction,
        async: true,
        func: async function (done) {
          try {
            // Run calibration (adapter handles UI)
            const result = await adapter.calibrate();
            calibration_attempts++;
            final_validation_data = result; // Store result
            done();
          } catch (e) {
            console.error('Calibration failed:', e);
            done();
          }
        }
      });

      return sequence;
    }

    // Add calibration
    timeline = timeline.concat(create_calibration_sequence());

    // Recalibration logic: Offer only if accuracy is poor
    var recalibration_offer = {
      timeline: [
        {
          type: jsPsychHtmlButtonResponse,
          stimulus: function () {
            var rmse = final_validation_data ? final_validation_data.rmse : 0;
            var accuracy_msg = rmse > 0.08 ? "Accuracy is low." : "Accuracy is good.";
            return `
              <div style="text-align: center; padding: 20px;">
                <h3>Calibration Check</h3>
                <p>RMSE: ${rmse.toFixed(3)} (${accuracy_msg})</p>
                <p>We recommend recalibrating to ensure best results.</p>
              </div>
            `;
          },
          choices: ['Recalibrate', 'Continue Anyway']
        },
        {
          timeline: create_calibration_sequence(),
          conditional_function: function () {
            var last_response = jsPsych.data.get().last(1).values()[0];
            return last_response.response === 0; // 0 is 'Recalibrate'
          }
        }
      ],
      conditional_function: function () {
        // Only show this screen if RMSE is worse than threshold (0.08)
        // Based on logs, good calibration is ~0.02 - 0.03
        var threshold = 0.08;
        var rmse = final_validation_data ? final_validation_data.rmse : null;

        console.log('[Calibration] Checking recalibration condition:');
        console.log('  RMSE:', rmse);
        console.log('  Threshold:', threshold);

        if (!final_validation_data || rmse === undefined || rmse === null) {
          console.log('  Decision: SHOW recalibration (no validation data available)');
          return true; // Safety fallback
        }

        var shouldShow = rmse > threshold;
        console.log('  Decision:', shouldShow ? 'SHOW recalibration (poor accuracy)' : 'SKIP recalibration (good accuracy)');
        return shouldShow;
      }
    };
    timeline.push(recalibration_offer);

    // Completion
    timeline.push({
      type: jsPsychHtmlButtonResponse,
      stimulus: '<h3>Calibration Complete!</h3><p>Proceeding...</p>',
      choices: [],
      trial_duration: 1000
    });

    // Start Tracking and Send Calibration Complete
    timeline.push({
      type: jsPsychCallFunction,
      async: true,
      func: async function (done) {
        console.log('[Calibration] Starting tracker...');
        try {
          await adapter.start();
          console.log('[Calibration] Adapter started successfully');
          initTrackingMode();

          // Send calibration-complete message to parent immediately
          // (Don't wait for on_finish since we'll enter infinite mode)
          if (window.parent !== window) {
            var model_key = 'webeyetrack_model_' + Date.now();
            window.parent.postMessage({
              type: 'calibration-complete',
              average_offset: final_validation_data ? final_validation_data.rmse : null,
              recalibrated: calibration_attempts > 1,
              calibration_attempts: calibration_attempts,
              validation_data: final_validation_data,
              model_key: model_key
            }, '*');
            console.log('[Calibration] Sent calibration-complete to parent, hiding iframe');
          }

          // Complete this trial to proceed to infinite tracking mode
          done();
        } catch (e) {
          console.error('[Calibration] Error starting adapter:', e);
          alert('Error starting eye tracking: ' + e.message);
          done();
        }
      }
    });

    // Conditional final trial based on context
    // In Qualtrics iframe: Keep jsPsych alive indefinitely for tracking
    // In standalone mode: Show completion message with close button
    const isInIframe = window.parent !== window;

    if (isInIframe) {
      // Qualtrics iframe mode: infinite trial (tracking stays active)
      timeline.push({
        type: jsPsychHtmlButtonResponse,
        stimulus: '<div style="text-align: center; color: #999;">Eye tracking active</div>',
        choices: [],
        trial_duration: null,
        on_load: function () {
          // Hide UI after calibration complete
          setTimeout(() => {
            const el = document.querySelector('#jspsych-html-button-response-stimulus');
            if (el) el.style.display = 'none';
          }, 1000);
        }
      });
    } else {
      // Standalone mode: show completion with close button
      timeline.push({
        type: jsPsychHtmlButtonResponse,
        stimulus: `
          <div style="text-align: center; padding: 40px;">
            <h2 style="color: #2ecc71;">Eye Tracking Active</h2>
            <p style="margin: 20px 0;">Calibration complete and tracker is running.</p>
            <p style="color: #666; font-size: 14px;">In Qualtrics, this iframe would remain hidden while tracking continues.</p>
            <p style="color: #666; font-size: 14px; margin-top: 30px;">You can close this window now or click the button below.</p>
          </div>
        `,
        choices: ['Close Window'],
        on_finish: function () {
          console.log('[Calibration] Standalone test complete - closing window');
          // In standalone mode, user can close the window
          // The tracker will continue running until page is closed
        }
      });
    }

    jsPsych.run(timeline);

    // Tracking Mode Logic
    var isTracking = false;
    var gazeBuffer = [];
    var viewportOffset = { scrollX: 0, scrollY: 0 };
    var sampleCount = 0;

    function initTrackingMode() {
      console.log('[Calibration] Initializing tracking mode...');
      isTracking = true; // Enable tracking by default for standalone testing

      // Create visual feedback dot
      const gazeDot = document.createElement('div');
      gazeDot.id = 'gaze-dot';
      gazeDot.style.position = 'fixed';
      gazeDot.style.width = '20px';
      gazeDot.style.height = '20px';
      gazeDot.style.backgroundColor = 'red';
      gazeDot.style.borderRadius = '50%';
      gazeDot.style.pointerEvents = 'none';
      gazeDot.style.zIndex = '9999';
      gazeDot.style.transform = 'translate(-50%, -50%)';
      gazeDot.style.display = 'none'; // Hidden initially
      document.body.appendChild(gazeDot);

      adapter.onSample((sample) => {
        sampleCount++;
        if (sampleCount % 60 === 0) { // Log every ~1s (at 60Hz) or ~4s (at 15Hz)
          console.log('[Calibration] Sample #' + sampleCount, sample);
        }

        // Update visual feedback
        gazeDot.style.display = 'block';
        gazeDot.style.left = sample.x + 'px';
        gazeDot.style.top = sample.y + 'px';

        if (!isTracking) {
          if (sampleCount % 60 === 0) {
            console.log('[Calibration] isTracking is FALSE, blocking postMessage (sample #' + sampleCount + ')');
          }
          return;
        }

        // Stream data to parent window (Qualtrics)
        if (window.parent !== window) {
          if (sampleCount % 60 === 0) {
            console.log('[Calibration] isTracking is TRUE, sending gaze-data to parent (sample #' + sampleCount + ')');
          }
          window.parent.postMessage({
            type: 'gaze-data',
            timestamp: sample.perf_t,
            x: sample.x + viewportOffset.scrollX,
            y: sample.y + viewportOffset.scrollY
          }, '*');
        }

        gazeBuffer.push({
          timestamp: sample.perf_t,
          x: sample.x + viewportOffset.scrollX,
          y: sample.y + viewportOffset.scrollY,
          rawX: sample.x,
          rawY: sample.y
        });
      });

      // Notify parent
      if (window.parent !== window) {
        window.parent.postMessage({ type: 'tracking-ready' }, '*');
      }
    }

    // Message Listener
    window.addEventListener('message', function (event) {
      var data = event.data;
      switch (data.type) {
        case 'start-tracking':
          console.log('[Calibration] Received START-TRACKING message');
          console.log('[Calibration] Before: isTracking =', isTracking);
          isTracking = true;
          gazeBuffer = [];
          console.log('[Calibration] After: isTracking =', isTracking);
          console.log('[Calibration] Tracking ACTIVE, buffer cleared');
          break;
        case 'pause-tracking':
          console.log('[Calibration] Received PAUSE-TRACKING message');
          isTracking = false;
          console.log('[Calibration] Sending', gazeBuffer.length, 'buffered samples to parent');
          if (window.parent !== window) {
            window.parent.postMessage({
              type: 'gaze-data-batch',
              samples: gazeBuffer
            }, '*');
          }
          break;
        case 'resume-tracking':
          isTracking = true;
          break;
        case 'viewport-update':
          viewportOffset.scrollX = data.scrollX || 0;
          viewportOffset.scrollY = data.scrollY || 0;
          break;
        case 'recalibrate':
          // Handle recalibration request
          // This is harder with jsPsych running an infinite trial.
          // We might need to stop the current trial?
          // For now, ignore or reload page.
          location.reload();
          break;
      }
    });

  </script>
</body>

</html>