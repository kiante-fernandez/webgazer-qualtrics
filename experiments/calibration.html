<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Eye Tracking Calibration</title>

  <!-- jsPsych Core -->
  <script src="https://unpkg.com/jspsych@8.2.2"></script>
  <link rel="stylesheet" href="https://unpkg.com/jspsych@8.2.2/css/jspsych.css" />

  <!-- jsPsych Plugins -->
  <script src="https://unpkg.com/@jspsych/plugin-html-button-response@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-call-function@1.1.3"></script>

  <!-- Gaze Adapter -->
  <script src="../dist/gaze-adapter.bundle.umd.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #f0f0f0;
    }
  </style>
</head>

<body>
  <div id="jspsych-target"></div>

  <script>
    var calibration_attempts = 0;
    var final_validation_data = null;
    var adapter = new GazeAdapter();

    // Initialize jsPsych
    var jsPsych = initJsPsych({
      on_finish: function (data) {
        // Use the final_validation_data we captured
        var validation_data = final_validation_data;

        // Save model key (WebEyeTrack handles persistence internally usually, but we simulate a key)
        var model_key = 'webeyetrack_model_' + Date.now();

        // Send data to parent window
        if (window.parent !== window) {
          window.parent.postMessage({
            type: 'calibration-complete',
            average_offset: validation_data ? validation_data.rmse : null,
            recalibrated: calibration_attempts > 1,
            calibration_attempts: calibration_attempts,
            validation_data: validation_data,
            model_key: model_key
          }, '*');
          console.log('Sent calibration data to parent window');
        } else {
          // Standalone mode
          console.log('Calibration complete!');
          console.log('Validation data:', validation_data);

          var offset_text = validation_data && validation_data.rmse !== undefined
            ? validation_data.rmse.toFixed(2) + ' (RMSE)'
            : 'Not available';

          document.querySelector('#jspsych-target').innerHTML =
            '<div style="text-align: center; padding: 50px; font-family: sans-serif;">' +
            '<h2>Calibration Complete!</h2>' +
            '<p>Accuracy: ' + offset_text + '</p>' +
            '<p>Calibration attempts: ' + calibration_attempts + '</p>' +
            '<p style="color: #666; font-size: 14px;">Check console for full data</p>' +
            '</div>';
        }
      }
    });

    var timeline = [];

    // Welcome
    timeline.push({
      type: jsPsychHtmlButtonResponse,
      stimulus: `
        <div style="text-align: center; padding: 20px; max-width: 600px; margin: 0 auto;">
          <h2>Eye Tracking Calibration</h2>
          <p>This study requires eye tracking to verify human participation.</p>
          <p>You will see dots appear on the screen. Please:</p>
          <ul style="text-align: left; margin: 20px auto; display: inline-block;">
            <li>Look directly at each dot</li>
            <li>The system will automatically calibrate</li>
          </ul>
        </div>
      `,
      choices: ['Start Calibration']
    });

    // Initialize Camera
    timeline.push({
      type: jsPsychCallFunction,
      async: true,
      func: async function (done) {
        try {
          await adapter.init();
          done();
        } catch (e) {
          alert('Camera initialization failed: ' + e.message);
          // Don't call done() to halt? Or proceed with error?
        }
      }
    });

    // Calibration Sequence Function
    function create_calibration_sequence() {
      var sequence = [];

      // Instructions
      sequence.push({
        type: jsPsychHtmlButtonResponse,
        stimulus: `
          <div style="text-align: center; padding: 20px;">
            <h3>Calibration Phase</h3>
            <p>Dots will appear on the screen.</p>
            <p>Look at them until they disappear.</p>
          </div>
        `,
        choices: ['Begin Calibration']
      });

      // Run Calibration
      sequence.push({
        type: jsPsychCallFunction,
        async: true,
        func: async function (done) {
          try {
            // Run calibration (adapter handles UI)
            const result = await adapter.calibrate();
            calibration_attempts++;
            final_validation_data = result; // Store result
            done();
          } catch (e) {
            console.error('Calibration failed:', e);
            done();
          }
        }
      });

      return sequence;
    }

    // Add calibration
    timeline = timeline.concat(create_calibration_sequence());

    // Recalibration logic (simplified for adapter)
    // We can check final_validation_data.rmse
    var recalibration_offer = {
      timeline: [
        {
          type: jsPsychHtmlButtonResponse,
          stimulus: function () {
            return `
              <div style="text-align: center; padding: 20px;">
                <h3>Calibration Accuracy</h3>
                <p>RMSE: ${final_validation_data ? final_validation_data.rmse.toFixed(2) : 'N/A'}</p>
                <p>Would you like to recalibrate?</p>
              </div>
            `;
          },
          choices: ['Yes, Recalibrate', 'No, Continue']
        },
        {
          timeline: create_calibration_sequence(),
          conditional_function: function () {
            var last_response = jsPsych.data.get().last(1).values()[0];
            return last_response.response === 0;
          }
        }
      ],
      conditional_function: function () {
        // Offer if RMSE is high (e.g. > 0.5? Unit depends on adapter)
        // Let's assume > 100 pixels equivalent or normalized > 0.1
        // Our dummy adapter returns 0.5.
        return calibration_attempts === 1;
      }
    };
    timeline.push(recalibration_offer);

    // Completion
    timeline.push({
      type: jsPsychHtmlButtonResponse,
      stimulus: '<h3>Calibration Complete!</h3><p>Proceeding...</p>',
      choices: [],
      trial_duration: 1000
    });

    // Infinite Tracking
    timeline.push({
      type: jsPsychCallFunction,
      async: true,
      func: async function (done) {
        console.log('[Calibration] Starting infinite tracking...');
        try {
          await adapter.start();
          console.log('[Calibration] Adapter started successfully');
          initTrackingMode();
        } catch (e) {
          console.error('[Calibration] Error starting adapter:', e);
          alert('Error starting eye tracking: ' + e.message);
        }
        // Do NOT call done() to keep this trial running forever?
        // jsPsychCallFunction expects done().
        // If we want to keep it alive, we can just NOT call done.
        // But we want to execute the 'on_finish' of the experiment?
        // The original code used an infinite trial.
        // We can use a trial with no end.
      }
    });

    // To keep jsPsych alive and showing something:
    timeline.push({
      type: jsPsychHtmlButtonResponse,
      stimulus: '<div style="text-align: center; color: #999;">Eye tracking active</div>',
      choices: [],
      trial_duration: null,
      on_load: function () {
        // Hide UI
        setTimeout(() => {
          const el = document.querySelector('#jspsych-html-button-response-stimulus');
          if (el) el.style.display = 'none';
        }, 1000);
      }
    });

    jsPsych.run(timeline);

    // Tracking Mode Logic
    var isTracking = false;
    var gazeBuffer = [];
    var viewportOffset = { scrollX: 0, scrollY: 0 };
    var sampleCount = 0;

    function initTrackingMode() {
      console.log('[Calibration] Initializing tracking mode...');
      isTracking = true; // Enable tracking by default for standalone testing

      // Create visual feedback dot
      const gazeDot = document.createElement('div');
      gazeDot.id = 'gaze-dot';
      gazeDot.style.position = 'fixed';
      gazeDot.style.width = '20px';
      gazeDot.style.height = '20px';
      gazeDot.style.backgroundColor = 'red';
      gazeDot.style.borderRadius = '50%';
      gazeDot.style.pointerEvents = 'none';
      gazeDot.style.zIndex = '9999';
      gazeDot.style.transform = 'translate(-50%, -50%)';
      gazeDot.style.display = 'none'; // Hidden initially
      document.body.appendChild(gazeDot);

      adapter.onSample((sample) => {
        sampleCount++;
        if (sampleCount % 60 === 0) { // Log every ~1s (at 60Hz) or ~4s (at 15Hz)
          console.log('[Calibration] Sample #' + sampleCount, sample);
        }

        // Update visual feedback
        gazeDot.style.display = 'block';
        gazeDot.style.left = sample.x + 'px';
        gazeDot.style.top = sample.y + 'px';

        if (!isTracking) return;

        // Stream data to parent window (Qualtrics)
        if (window.parent !== window) {
          window.parent.postMessage({
            type: 'gaze-data',
            timestamp: sample.perf_t,
            x: sample.x + viewportOffset.scrollX,
            y: sample.y + viewportOffset.scrollY
          }, '*');
        }

        gazeBuffer.push({
          timestamp: sample.perf_t,
          x: sample.x + viewportOffset.scrollX,
          y: sample.y + viewportOffset.scrollY,
          rawX: sample.x,
          rawY: sample.y
        });
      });

      // Notify parent
      if (window.parent !== window) {
        window.parent.postMessage({ type: 'tracking-ready' }, '*');
      }
    }

    // Message Listener
    window.addEventListener('message', function (event) {
      var data = event.data;
      switch (data.type) {
        case 'start-tracking':
          isTracking = true;
          gazeBuffer = [];
          break;
        case 'pause-tracking':
          isTracking = false;
          if (window.parent !== window) {
            window.parent.postMessage({
              type: 'gaze-data-batch',
              samples: gazeBuffer
            }, '*');
          }
          break;
        case 'resume-tracking':
          isTracking = true;
          break;
        case 'viewport-update':
          viewportOffset.scrollX = data.scrollX || 0;
          viewportOffset.scrollY = data.scrollY || 0;
          break;
        case 'recalibrate':
          // Handle recalibration request
          // This is harder with jsPsych running an infinite trial.
          // We might need to stop the current trial?
          // For now, ignore or reload page.
          location.reload();
          break;
      }
    });

  </script>
</body>

</html>